import { Injectable } from '@nestjs/common';
import { RuleEngine } from './rules/rule-engine';
import { RulePack, ComplianceDecision } from './ai-legal.types';
import { AskLegalQueryDto } from './dto/ask-legal-query.dto';
import { PrismaService } from '../../prisma.service';
import OpenAI from 'openai';

interface StoredQuery {
  id: string;
  tenantId: string;
  userId: string;
  question: string;
  response: ComplianceDecision;
  category?: string;
  resolved?: boolean;
  createdAt: Date;
}

@Injectable()
export class AiLegalService {
  private queries: StoredQuery[] = [];
  private openai: OpenAI;
  private model: string;

  constructor(private prisma: PrismaService, private packs: RulePack[] = []) {
    if (!process.env.OPENAI_API_KEY) {
      console.warn('⚠️ OPENAI_API_KEY not set. AiLegalService will fail on calls.');
    }
    this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
  }

  /**
   * Core runner for legal compliance queries.
   */
  async askLegalQuery(
    tenantId: string,
    userId: string,
    question: string,
  ): Promise<ComplianceDecision> {
    const engine = new RuleEngine(this.packs);
    const evaluations = await engine.execute(question);

    let status: ComplianceDecision['status'] = 'passed';
    if (evaluations.some((r) => r.action === 'fail' && r.triggered)) {
      status = 'failed';
    } else if (evaluations.some((r) => r.action === 'review' && r.triggered)) {
      status = 'manual_review';
    }

    return {
      status,
      rules: evaluations,
      notes: evaluations.map((r) => r.notes).filter(Boolean).join('; '),
    };
  }

  /**
   * Wraps askLegalQuery to accept DTO directly from controller.
   * Uses both RuleEngine (basic checks) + OpenAI (legal assistant).
   */
  async createQuery(dto: AskLegalQueryDto) {
    if (!dto.tenantId) throw new Error('Tenant ID required');

    // --- Run local RuleEngine first ---
    const engine = new RuleEngine(this.packs);
    const ruleResult = engine.run(dto.question, dto.category);
    const evaluations = await engine.execute(dto.question);

    let status: 'passed' | 'failed' | 'manual_review' = 'passed';
    if (ruleResult.flagged) {
      status = 'manual_review';
    }
    if (evaluations.some((r) => r.action === 'fail' && r.triggered)) {
      status = 'failed';
    }

    // --- Call OpenAI Legal Assistant ---
    const systemPrompt = `
You are a legal compliance assistant for India. 
You must answer user questions strictly based on Indian law, RBI guidelines, Income Tax Act, GST, FEMA, SEBI, Companies Act, and other official regulations.
Always provide citations to relevant rules/sections if available.
If unsure, say you cannot give a definitive legal opinion and suggest consulting a professional.
Answer in clear, professional tone.
    `;

    let aiAnswer = '';
    try {
      const response = await this.openai.chat.completions.create({
        model: this.model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: dto.question },
        ],
        temperature: 0.2,
      });

      aiAnswer = response.choices[0]?.message?.content || '';
    } catch (err) {
  if (err instanceof Error) {
    console.error("❌ OpenAI error:", err.message);
  } else {
    console.error("❌ OpenAI error:", err);
  }
  aiAnswer = "⚠️ Could not fetch AI response. Using rule-based answer only.";
}
    // --- Save in DB ---
    const query = await this.prisma.legalQuery.create({
      data: {
        tenantId: dto.tenantId,
        userId: dto.userId,
        question: dto.question,
        category: dto.category || 'Custom',
        status,
        answer: aiAnswer || ruleResult.answer || 'No answer generated',
        explanation:
          ruleResult.explanation ||
          'Generated by LegalAI assistant using OpenAI and local rules',
      },
    });

    return query;
  }

  /**
   * Returns a previously stored query by ID.
   */
  async getQuery(id: string): Promise<StoredQuery | undefined> {
    return this.queries.find((q) => q.id === id);
  }

  /**
   * Lists all queries (legacy in-memory, kept for compatibility).
   */
  async listQueries(): Promise<StoredQuery[]> {
    return this.queries;
  }

  /**
   * Marks a query as resolved.
   */
  async resolveQuery(id: string): Promise<StoredQuery | undefined> {
    const q = this.queries.find((q) => q.id === id);
    if (q) {
      q.resolved = true;
    }
    return q;
  }

  /**
   * Specialized check for payments.
   */
  async checkPayment(payment: any) {
    const question = `Is this payment compliant? amount=${payment.amount}, currency=${payment.currency}`;
    return this.askLegalQuery(payment.tenantId, payment.userId, question);
  }
}
